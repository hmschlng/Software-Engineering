# 6-3 Architectural Patterns
---
<br>

### ✅ Architectural patterns (아키텍처 패턴)

- 패턴은 지식을 표현하고, 공유하고, 재사용하는 수단이다.
<br>

- 건축 패턴은 다양한 환경에서 시도되고 테스트된 우수 설계 관행에 대한 양식화된 설명입니다.
<br>

- 패턴에는 언제가 유용한지, 언제가 유용하지 않은지에 대한 정보가 포함되어야 한다.
<br>

- 패턴은 표 및 그래픽 설명을 사용하여 나타낼 수 있습니다.
<br>

### ✅ The Model-View-Controller (MVC) pattern (MVC 패턴)
<table>
  <tr>
    <td><b>이름</td>
    <td><b>MVC Pattern</td>
  </tr>
  <tr>
    <td>설명</td>
    <td>프레젠테이션 및 상호 작용을 시스템 데이터에서 분리합니다. 시스템은 서로 상호 작용하는 세 가지 논리적 구성요소로 구성됩니다. 모델 구성 요소는 시스템 데이터 및 해당 데이터에 대한 관련 작업을 관리합니다. 보기 구성 요소는 데이터가 사용자에게 표시되는 방식을 정의하고 관리합니다. 컨트롤러 구성요소는 사용자 상호 작용(예: 키 누르기, 마우스 클릭 등)을 관리하고 이러한 상호 작용을 보기 및 모델로 전달합니다.</td>
  </tr>
  <tr>
    <td>주로 사용되는 상황</td>
    <td>데이터를 보고 상호 작용하는 여러 가지 방법이 있을 때 사용합니다. 또한 상호 작용 및 데이터 표시에 대한 향후 요구 사항을 알 수 없는 경우에도 사용됩니다.</td>
  </tr>
  <tr>
    <td>장점</td>
    <td>데이터가 표현과 무관하게 변경될 수 있습니다.
모든 데이터에 표시된 하나의 표현에서 변경된 내용을 사용하여 동일한 데이터를 다른 방식으로 표시할 수 있습니다.<br>
    즉, 부분 보수에 유리합니다.</td>
  </tr>
  <tr>
    <td>단점</td>
    <td>데이터 모델 및 상호 작용이 단순할 경우 코드 및 코드 복잡성이 추가로 발생할 수 있습니다.</td>
  </tr>
</table>
<br>

#### MVC 패턴의 구조도
![캡처](https://i.imgur.com/AiPhB3a.png)
<br>

#### MVC 패턴을 사용한 웹 어플리케이션의 구조도
MVC 패턴을 사용하여 구성된 웹 기반 애플리케이션 시스템의 아키텍처입니다.

![캡처](https://i.imgur.com/YDNE7wn.png)
<br>

### ✅ Layered architecture (계층적 아키텍처)

- 하위 시스템의 인터페이스를 모델링하는 데 사용됩니다.
<br>

- 시스템을 계층 집합(또는 추상 시스템)으로 구성하며, 각 계층은 서비스 집합을 제공합니다.
<br>

- 서로 다른 계층에서 하위 시스템의 증분 개발을 지원합니다. 계층 인터페이스가 변경되면 인접한 계층만 영향을 받습니다.
<br>

- 그러나 이러한 방식으로 시스템을 구조화하는 것은 종종 인위적입니다.
<br>

### ✅ The Layered architecture pattern (Layered 아키텍처 패턴)
<table>
  <tr>
    <td><b>이름</td>
    <td><b>Layered Architecture Pattern</td>
  </tr>
  <tr>
    <td>설명</td>
    <td>시스템을 각 계층과 관련된 기능을 가진 계층으로 구성합니다. 계층은 계층 위에 있는 계층에 서비스를 제공하여 가장 낮은 수준의 계층이 시스템 전체에서 사용될 가능성이 높은 핵심 서비스를 나타냅니다.</td>
  </tr>
  <tr>
    <td>주로 사용되는 상황</td>
    <td>기존 시스템 위에 새로운 시설을 구축할 때, 각 팀이 기능 계층을 담당하는 여러 팀으로 개발이 분산될 때, 다단계 보안에 대한 요구사항이 있을 때 사용됩니다.</td>
  </tr>
  <tr>
    <td>장점</td>
    <td>인터페이스가 유지되는 한 전체 도면층을 교체할 수 있습니다. 시스템의 신뢰성을 높이기 위해 각 계층에 중복 기능(예: 인증)을 제공할 수 있다.</td>
  </tr>
  <tr>
    <td>단점</td>
    <td>실제로, 계층들 사이에 깨끗한 분리를 제공하는 것은 종종 어렵고 높은 수준의 계층은 바로 아래의 계층을 통해서가 아니라 낮은 수준의 계층들과 직접적으로 상호작용해야 할 수 있다. 서비스 요청이 각 계층에서 처리되기 때문에 여러 수준의 해석으로 인해 성능이 문제가 될 수 있습니다.</td>
  </tr>
</table>
<br>

#### Layered 아키텍처의 일반적 구조
![캡처](https://i.imgur.com/QXJCf3l.png)
<br>

#### 예시 : iLearn 시스템의 아키텍처
서로 다른 라이브러리에 있는 저작권 문서를 공유하기 위한 시스템의 계층화 모델입니다.

![캡처](https://i.imgur.com/yH8UgJZ.png)
<br>

### ✅ Repository architecture (리포지토리 아키텍처)

- 하위 시스템은 데이터를 교환해야 합니다. 이 작업은 두 가지 방법으로 수행할 수 있습니다.
  - 공유 데이터는 중앙 데이터베이스 또는 저장소에 보관되며 모든 하위 시스템에서 액세스할 수 있습니다.
  - 각 하위 시스템은 자체 데이터베이스를 유지하고 데이터를 다른 하위 시스템에 명시적으로 전달합니다.
<br>

- 많은 양의 데이터를 공유해야 할 때, 효율적인 데이터 공유 메커니즘인 공유 저장소 모델이 가장 일반적으로 사용됩니다.
<br>

### ✅ The Repository pattern (리포지토리 패턴)
<table>
  <tr>
    <td><b>이름</td>
    <td><b>Repository Pattern</td>
  </tr>
  <tr>
    <td>설명</td>
    <td>시스템의 모든 데이터는 모든 시스템 구성 요소가 액세스할 수 있는 중앙 저장소에서 관리됩니다. 구성 요소는 저장소를 통해서만 직접 상호 작용하지 않습니다.</td>
  </tr>
  <tr>
    <td>주로 사용되는 상황</td>
    <td>이 패턴은 대량의 정보가 생성되어 장기간 저장되어야 하는 시스템이 있을 때 사용해야 합니다. 또한 저장소에 데이터를 포함하면 작업 또는 도구가 트리거되는 데이터 기반 시스템에서 사용할 수도 있습니다.</td>
  </tr>
  <tr>
    <td>장점</td>
    <td>구성요소는 독립적일 수 있습니다. 구성요소는 다른 구성요소의 존재를 알 필요가 없습니다. 한 구성 요소의 변경 내용을 모든 구성 요소로 전파할 수 있습니다. 모든 데이터를 한 곳에서 일관되게 관리할 수 있습니다(예: 동시에 수행되는 백업).</td>
  </tr>
  <tr>
    <td>단점</td>
    <td>실제로, 계층들 사이에 깨끗한 분리를 제공하는 것은 종종 어렵고 높은 수준의 계층은 바로 아래의 계층을 통해서가 아니라 낮은 수준의 계층들과 직접적으로 상호작용해야 할 수 있다. 서비스 요청이 각 계층에서 처리되기 때문에 여러 수준의 해석으로 인해 성능이 문제가 될 수 있습니다.</td>
  </tr>
</table>
<br>

#### 예시 : IDE의 리포지토리 아키텍처
구성 요소가 시스템 설계 정보의 저장소를 사용하는 IDE의 예입니다. 각 소프트웨어 도구는 다른 도구에서 사용할 수 있는 정보를 생성합니다.

![캡처](https://i.imgur.com/A25XKha.png)
<br>

### ✅ Client-server architecture (클라이언트 - 서버 아키텍처)

- 데이터 및 처리가 다양한 구성요소에 분산되는 방식을 보여주는 분산 시스템 모델입니다.
  - 단일 컴퓨터에서 구현할 수 있습니다.
<br>

- 인쇄, 데이터 관리 등과 같은 특정 서비스를 제공하는 독립 실행형 서버 집합
<br>

- 이러한 서비스를 호출하는 클라이언트 집합입니다.
<br>

- 클라이언트가 서버에 액세스할 수 있는 네트워크입니다.
<br>

### ✅ The Client–server pattern (클라이언트 - 서버 패턴)
<table>
  <tr>
    <td><b>이름</td>
    <td><b>Client–server Pattern</td>
  </tr>
  <tr>
    <td>설명</td>
    <td>클라이언트-서버 아키텍처에서 시스템의 기능은 서비스로 구성되며, 각 서비스는 별도의 서버에서 전달됩니다. 클라이언트는 이러한 서비스의 사용자이며 서비스를 사용하기 위해 서버에 액세스합니다.</td>
  </tr>
  <tr>
    <td>주로 사용되는 상황</td>
    <td>공유 데이터베이스의 데이터에 다양한 위치에서 액세스해야 할 때 사용됩니다. 서버를 복제할 수 있기 때문에, 시스템의 로드가 가변적일 때에도 사용될 수 있습니다.</td>
  </tr>
  <tr>
    <td>장점</td>
    <td>이 모델의 주요 장점은 네트워크를 통해 서버를 배포할 수 있다는 것입니다. 일반 기능(예: 인쇄 서비스)은 모든 클라이언트가 사용할 수 있으며 모든 서비스에 의해 구현될 필요는 없습니다.</td>
  </tr>
  <tr>
    <td>단점</td>
    <td>각 서비스는 서비스 거부 공격 또는 서버 장애의 영향을 받기 쉬운 단일 장애 지점입니다. 성능은 시스템뿐만 아니라 네트워크에 따라 달라지기 때문에 예측할 수 없습니다. 서버가 서로 다른 조직에서 소유하는 경우 관리 문제가 발생할 수 있습니다.</td>
  </tr>
</table>
<br>

#### 예시 : 영화 저장소 서비스의 클라이언트 - 서버 아키텍처
![캡처](https://i.imgur.com/9ov8RDc.png)
<br>

### ✅ Pipe and filter architecture (파이프 - 필터 아키텍처)

- 기능 변환은 입력을 처리하여 출력을 생성합니다.
<br>

- 파이프 및 필터 모델이라고 할 수 있습니다(UNIX 쉘에서).
<br>

- 이 접근법의 변형은 매우 흔하다. 변환이 순차적일 때, 이것은 데이터 처리 시스템에 광범위하게 사용되는 배치 순차 모델입니다.
<br>

- 대화형 시스템 (Interactive System) 에는 적합하지 않습니다.
<br>

### ✅ The pipe and filter pattern (파이프 - 필터 패턴)
<table>
  <tr>
    <td><b>이름</td>
    <td><b>Pipe and Filter Pattern</td>
  </tr>
  <tr>
    <td>설명</td>
    <td>시스템의 데이터 처리는 각 처리 구성요소(필터)가 개별화되어 하나의 유형의 데이터 변환을 수행하도록 구성된다. 데이터는 처리를 위해 한 구성 요소에서 다른 구성 요소로 흐릅니다.</td>
  </tr>
  <tr>
    <td>주로 사용되는 상황</td>
    <td>데이터 처리 응용 프로그램(배치 기반 및 트랜잭션 기반 모두)에서 일반적으로 사용되며, 입력은 관련 출력을 생성하기 위해 별도의 단계로 처리됩니다.</td>
  </tr>
  <tr>
    <td>장점</td>
    <td>이해하기 쉽고 변환 재사용을 지원합니다. 워크플로 스타일은 여러 비즈니스 프로세스의 구조와 일치합니다. 변화를 추가함으로써 진화는 간단합니다. 순차 또는 동시 시스템으로 구현할 수 있습니다.</td>
  </tr>
  <tr>
    <td>단점</td>
    <td>데이터 전송 형식이 통신 변환 간에 합의되어야만 전송이 가능합니다. 각 변환은 입력을 파싱하고 출력을 합의된 형식으로 언파싱해야 합니다. 이는 시스템 오버헤드를 증가시키고 호환되지 않는 데이터 구조를 사용하는 기능 변환을 재사용하는 것이 불가능함을 의미합니다.</td>
  </tr>
</table>
<br>

#### 예시 : 송장 처리 시스템에 사용되는 파이프 - 필터 패턴 아키텍처

송장 처리에 사용되는 파이프 및 필터 시스템의 예입니다.

![캡처](https://i.imgur.com/ZGFyB7l.png)
<br>
