# 🍎 3-2 Agile Development Techniques
---
<br>

### ✅ Extreme Programming (익스트림 프로그래밍)
- 1990년대 후반에 개발된 매우 영향력 있는 애자일 방법으로 다양한 애자일 개발 기술을 도입했습니다.
<br>

- 익스트림 프로그래밍(XP)은 **반복 개발에 대해 '극단적' 접근 방식**을 취합니다.
  - 새 버전은 하루에 여러 번 빌드될 수 있습니다.
  - 증분은 2주마다 고객에게 전달됩니다.
  - 모든 테스트는 모든 빌드에 대해 실행되어야 하며 테스트가 성공적으로 실행된 경우에만 빌드가 수락됩니다.
<br>

### ✅ The extreme programming release cycle (익스트림 프로그래밍 릴리스 주기)
![1](https://i.imgur.com/uI2hoed.png)
<br>

### ✅ Extreme programming practices 
<table>
  <tr>
    <td><b>원칙 또는 관행</td>
    <td><b>설명</td>
  </tr>
  <tr>
    <td>점진적인 계획</td>
    <td>
      <b>요구 사항은 "스토리 카드"에 기록되며</b>, 배포에 포함될 스토리는 가용 시간과 상대적 우선 순위를 기준으로 결정됩니다. <br>
      개발자는 이러한 스토리를 개발 '작업'으로 나눕니다.</td>
  </tr>
  <tr>
    <td>소규모 릴리스</td>
    <td>
      개발을 할 때, <b>비즈니스 가치를 제공하는 최소한의 유용한 기능들을 먼저 개발</b>합니다.<br>
      시스템 릴리스는 첫 번째 릴리스에 점진적으로 기능들을 추가하는 형태로 빈번하게 진행됩니다.</td>
  </tr>
  <tr>
    <td>심플한 디자인</td>
    <td>
      설계는 현재 요구 사항을 충족하기 <b>최소한의 설계</b>만으로 충분하고, 그 이상은  하지 않습니다.</td>
  </tr>
  <tr>
    <td>테스트 우선 개발</td>
    <td>
      자동화된 유닛 테스트 프레임워크가 사용되며, 새로운 기능을 구현하기 전에 테스트가 먼저 시행됩니다.</td>
  </tr>
  <tr>
    <td>리팩토링</td>
    <td>
      개발자들은 코드 개선점이 발견되면 가능한 한 빠르고 지속적으로 리팩토링을 수행합니다. 이것은 코드를 단순하고 유지가능하게 합니다.</td>
  </tr>
  <tr>
    <td>페어 프로그래밍</td>
    <td>
      <b/>개발자들은 짝을 이루어 개발<b/>하며, 서로의 작업을 확인하고 항상 좋은 일을 할 수 있도록 지원합니다.</td>
  </tr>
  <tr>
    <td>집단 소유권</td>
    <td>
      한 쌍의 개발자는 시스템의 모든 영역에서 작업하므로, 전문 지식의 섬이 개발되지 않고 <br>
      모든 개발자가 모든 코드에 대해 책임을 집니다. <br>
      누구나 무엇이든 바꿀 수 있습니다.</td>
  </tr>
  <tr>
    <td>연속적인 통합</td>
    <td>
      작업에 대한 작업이 완료되는 즉시 전체 시스템에 통합됩니다. <br>
      이러한 통합 후에는 시스템의 모든 단위 테스트를 통과해야 합니다.</td>
  </tr>
  <tr>
    <td>유지 가능한 속도</td>
    <td>
      많은 양의 초과 근무는 허용되지 않습니다. 이는 코드 품질과 중기(medium term) 생산성이 오히려 저하될 수 있기 때문입니다. </td>
  </tr>
  <tr>
    <td>현장 고객</td>
    <td>
      시스템의 엔드포인트 유저(고객)의 대표는 XP 팀이 필요로 할 때 지원할 수 있도록 full time으로 일할 수 있어야 합니다. <br>
      XP 프로세스에서 고객은 개발 팀의 구성원이며, 구현을 위해 팀에 시스템 요구 사항을 제공할 책임이 있습니다.</td>
  </tr>
</table>
<br>

### ✅ XP and agile principles (XP와 애자일 원칙)
- **증분 개발** (Incremental Development)
  - 증분 개발은 소규모의 빈번한 시스템 릴리스를 통해 이루어집니다.
<br>

- **고객 참여** (Customer Involvement)
  - 고객 참여는 고객이 팀과 함께 풀타임으로 참여하는 것을 의미합니다.
<br>

- **프로세스가 아닌 사람에 집중** (People, not Process)
  - 페어 프로그래밍, 공동 소유권 및 초과근무 지양적 프로세스 등, 프로세스가 아닌 사람에 집중합니다.
<br>

- **변화 수용** (Embrace Change)
  - 일반 시스템 릴리스를 통해 변경 사항이 꾸준히 적용됩니다.
<br>

- **단순성 유지** (Maintaining Simplicity)
  - 지속적인 리팩토링을 통해 단순성을 유지합니다..
<br>

### ✅ Influential XP practices (영향력 있는 XP 관행)
- 익스트림 프로그래밍은 기술적인 부분에서만 초점이 맞춰져 있어, 실제 현업에서의 조직관리와 통합되기는 쉽지 않습니다.
<br>

- 결과적으로, 애자일 개발을 할 때 XP의 방식을 사용하긴 하지만, XP에 정의된 방법 그대로는 잘 사용되지 않습니다.
<br>

- 실무에서 자주 사용되는 활동
  - 사양에 대한 사용자 스토리
  - 리팩토링
  - 테스트 우선 개발
  - 페어 프로그래밍
<br>

### ✅ User stories for requirements (요구 사항에 대한 사용자 스토리)
- XP에서 고객 또는 사용자는 XP 팀의 일부이며 요구 사항에 대한 결정을 내릴 책임이 있습니다.
<br>

- 사용자 요구 사항은 사용자 스토리 또는 시나리오로 표현됩니다.
<br>

- 이것들은 카드에 쓰여 있고 개발팀은 이를 구현 작업으로 나눕니다. 이러한 작업은 일정 및 비용 견적의 기초입니다.
<br>

- 고객은 우선순위와 예상 일정에 따라 다음 릴리스에 포함할 스토리를 선택합니다.
<br>

#### A ‘prescribing medication’ story
![1](https://i.imgur.com/MPHdHQi.png)
사용자 스토리의 예시(Mentcare System)
<br>

#### Examples of Task Cards for Prescribing Medication 
![1](https://i.imgur.com/0lsBF3I.png)
위의 스토리를 Task로 정리한 부분
<br>

### ✅ Refactoring (리팩토링)
- 소프트웨어 공학의 일반적인 통념은 변화를 위한 설계입니다. 수명 주기 후반에 비용이 절감되므로 변화를 예상하는 데 시간과 노력을 투자할 가치가 있습니다.
<br>

- 그러나 XP는 변경 사항을 안정적으로 예상할 수 없기 때문에 이것이 가치가 없다고 주장합니다.
<br>

- 그 대신, 구현해야 할 때 변경을 쉽게 하기 위해 지속적인 코드 개선(리팩토링)을 제안합니다.
<br>

- 프로그래밍 팀은 가능한 소프트웨어 개선 사항을 찾고 당장 필요하지 않은 경우에도 개선합니다.
<br>

- 이것은 소프트웨어의 이해도를 향상시키고 문서화의 필요성을 줄입니다.
<br>

- 코드가 체계적이고 명확하기 때문에 변경이 더 쉽습니다.
<br>

- 그러나 일부 변경에는 아키텍처 리팩토링이 필요하며 이는 훨씬 더 비쌉니다.
<br>

### ✅ Examples of refactoring (리팩토링의 예)
- 중복 코드를 제거하기 위해 클래스 계층 구조를 재구성합니다.
<br>

- 속성과 메서드를 정리하고 이름을 변경하여 이해하기 쉽도록 합니다.
<br>

- 인라인 코드를 프로그램 라이브러리에 포함된 메서드 호출로 대체합니다.
<br>

### ✅ Test-first development (테스트 우선 개발)
- 테스트는 XP의 핵심이며 XP는 모든 변경이 이루어진 후 프로그램을 테스트하는 접근 방식을 개발했습니다.
<br>

- XP 테스트 기능:
  - 테스트 우선 개발.
  - 시나리오에서 증분 테스트 개발.
  - 테스트 개발 및 검증에 사용자 참여.
  - 자동화된 테스트 하네스는 새 릴리스가 구축될 때마다 모든 구성 요소 테스트를 실행하는 데 사용됩니다.
<br>

### ✅ Test-driven development (테스트 주도 개발)
- 코드를 작성하기 전에 테스트를 작성하면 구현해야 할 요구 사항이 명확해집니다.
<br>

- 테스트는 데이터가 아닌 프로그램으로 작성되어 자동으로 실행될 수 있습니다. 테스트에는 올바르게 실행되었는지 확인하는 작업이 포함됩니다.
  - 일반적으로 JUnit과 같은 테스트 프레임워크에 의존합니다.
<br>

- 새로운 기능이 추가되면 모든 이전 및 새 테스트가 자동으로 실행되므로 새 기능으로 인해 오류가 발생하지 않았는지 확인합니다.
<br>

### ✅ Customer involvement (고객 참여)
- 테스트 프로세스에서 고객의 역할은 시스템의 다음 릴리스에서 구현될 스토리에 대한 승인 테스트를 개발하는 것을 돕는 것입니다.
<br>

- 팀의 일원인 고객은 개발이 진행됨에 따라 테스트를 작성합니다. 따라서 모든 새로운 코드는 고객이 필요로 하는 것인지 확인하기 위해 검증됩니다.
<br>

- 그러나 고객 역할을 맡는 사람들은 시간이 제한되어 있으므로 개발 팀에서 풀타임으로 일하는 것이 쉽지는 않습니다. 그들은 요구 사항을 제공하는 것이 기여하기에 충분하다고 생각할 수 있으므로 테스트 프로세스에 참여하는 것을 꺼릴 수 있습니다.
<br>

#### 약물 복용량 확인을 위한 테스트 사례 설명
![1](https://i.imgur.com/AJcFHI1.png)
<br>

### ✅ Test automation (테스트 자동화)
- 테스트 자동화는 작업이 구현되기 전에 테스트를 실행 가능한 구성 요소로 작성하는 것을 의미합니다.
  - 이러한 테스트 구성 요소는 독립 실행형이어야 하며 테스트할 입력 제출을 시뮬레이션해야 하며 결과가 출력 사양을 충족하는지 확인해야 합니다. 자동화된 테스트 프레임워크(예: Junit)는 실행 가능한 테스트를 쉽게 작성하고 실행할 테스트 세트를 제출할 수 있게 해주는 시스템입니다.
<br>

- 테스트가 자동화되어 있기 때문에 항상 빠르고 쉽게 실행할 수 있는 테스트 세트가 있습니다.
  - 시스템에 기능이 추가될 때마다 테스트를 실행할 수 있고 새로운 코드가 도입한 문제를 즉시 포착할 수 있습니다.
<br>

### ✅ Problems with test-first development (테스트 우선 개발의 문제점)
- 프로그래머는 테스트보다 프로그래밍을 선호하며 테스트를 작성할 때 지름길을 택하기도 합니다. 예를 들어, 발생할 수 있는 모든 가능한 예외를 확인하지 않는 불완전한 테스트를 작성할 수 있습니다.
<br>

- 일부 테스트는 점진적으로 작성하기가 매우 어려울 수 있습니다.
예를 들어 복잡한 사용자 인터페이스에서는 화면 간의 '디스플레이 로직'과 워크플로를 구현하는 코드에 대한 단위 테스트를 작성하기 어려운 경우가 많습니다.
<br>

- 일련의 테스트의 완성도를 판단하는 것은 어렵습니다.
많은 시스템 테스트가 있을 수 있지만 테스트 세트가 완전한 범위를 제공하지 않을 수 있습니다.
<br>

### ✅ Pair programming (페어 프로그래밍)
- 페어 프로그래밍은 프로그래머가 **짝을 이루어 함께 코드를 개발**하는 것을 포함합니다.
<br>

- 이는 코드의 **공통 소유권**을 개발하고 팀 전체에 지식을 확산하는 데 도움이 됩니다.
<br>

- 1인 이상의 사람이 한 줄의 코드를 살펴보는 비공식적인 검토 프로세스 역할을 합니다.
<br>

- **전체 팀이 시스템 코드 개선의 이점을 얻을 수 있으므로** 리팩토링을 권장합니다.
<br>

- 페어 프로그래밍에서 프로그래머는 소프트웨어를 개발하기 위해 같은 컴퓨터에 함께 앉습니다.
<br>

- **페어는 동적으로 생성**되어 모든 팀 구성원이 개발 프로세스 중에 서로 협력할 수 있습니다.
<br>

- 페어 프로그래밍 중에 발생하는 **지식 공유**는 **팀원이 떠날 때 프로젝트에 대한 전반적인 위험을 줄이기 때문에 매우 중요**합니다.
<br>

- 짝 프로그래밍이 반드시 비효율적인 것은 아니며 함께 작업하는 2명의 프로그래머가 따로 작업하는 것보다 더 효율적이라는 증거가 있습니다.
<br>